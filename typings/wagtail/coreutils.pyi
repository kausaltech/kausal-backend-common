"""
This type stub file was generated by pyright.
"""

import functools
from collections.abc import Iterable
from typing import Any

from django.core.signals import setting_changed
from django.db.models import Model
from django.db.models.base import ModelBase
from django.dispatch import receiver
from django.http import HttpRequest
from wagtail.models import Site

logger = ...
WAGTAIL_APPEND_SLASH = ...

def camelcase_to_underscore(value: str) -> str:
    ...

def string_to_ascii(value: str) -> str:
    """
    Convert a string to ascii.
    """
    ...

def get_model_string(model: Model) -> str:
    """
    Returns a string that can be used to identify the specified model.

    The format is: `app_label.ModelName`

    This an be reversed with the `resolve_model_string` function
    """
    ...

def resolve_model_string(model_string, default_app=...): # -> type[Any] | type:
    """
    Resolve an 'app_label.model_name' string into an actual model class.
    If a model class is passed in, just return that.

    Raises a LookupError if a model can not be found, or ValueError if passed
    something that is neither a model or a string.
    """
    ...

SCRIPT_RE = ...
def escape_script(text: str) -> str:
    """
    Escape `</script>` tags in 'text' so that it can be placed within a `<script>` block without
    accidentally closing it. A '-' character will be inserted for each time it is escaped:
    `<-/script>`, `<--/script>` etc.
    """
    ...

SLUGIFY_RE = ...
def cautious_slugify(value: str) -> str:
    """
    Convert a string to ASCII exactly as Django's slugify does, with the exception
    that any non-ASCII alphanumeric characters (that cannot be ASCIIfied under Unicode
    normalisation) are escaped into codes like 'u0421' instead of being deleted entirely.

    This ensures that the result of slugifying (for example - Cyrillic) text will not be an empty
    string, and can thus be safely used as an identifier (albeit not a human-readable one).
    """
    ...

def safe_snake_case(value: str) -> str:
    """
    Convert a string to ASCII similar to Django's slugify, with cautious handling of
    non-ASCII alphanumeric characters. See `cautious_slugify`.

    Any inner whitespace, hyphens or dashes will be converted to underscores and
    will be safe for Django template or filename usage.
    """
    ...

def get_content_type_label(content_type): # -> _StrPromise | str:
    """
    Return a human-readable label for a content type object, suitable for display in the admin
    in place of the default 'wagtailcore | page' representation
    """
    ...

def accepts_kwarg(func, kwarg): # -> bool:
    """
    Determine whether the callable `func` has a signature that accepts the keyword argument `kwarg`
    """
    ...

class InvokeViaAttributeShortcut:
    """
    Used to create a shortcut that allows an object's named
    single-argument method to be invoked using a simple
    attribute reference syntax. For example, adding the
    following to an object:

    obj.page_url = InvokeViaAttributeShortcut(obj, 'get_page_url')

    Would allow you to invoke get_page_url() like so:

    obj.page_url.terms_and_conditions

    As well as the usual:

    obj.get_page_url('terms_and_conditions')
    """
    def __init__(self, obj, method_name) -> None:
        ...

    def __getattr__(self, name): # -> Any:
        ...

    def __getstate__(self): # -> dict[str, Any]:
        ...

    def __setstate__(self, state): # -> None:
        ...



def find_available_slug(parent, requested_slug, ignore_page_id=...):
    """
    Finds an available slug within the specified parent.

    If the requested slug is not available, this adds a number on the end, for example:

     - 'requested-slug'
     - 'requested-slug-1'
     - 'requested-slug-2'

    And so on, until an available slug is found.

    The `ignore_page_id` keyword argument is useful for when you are updating a page,
    you can pass the page being updated here so the page's current slug is not
    treated as in use by another page.
    """
    ...

@functools.cache
def get_content_languages(): # -> dict[str, Any]:
    """
    Cache of settings.WAGTAIL_CONTENT_LANGUAGES in a dictionary for easy lookups by key.
    """
    ...

@functools.lru_cache(maxsize=1000)
def get_supported_content_language_variant(lang_code, strict=...): # -> str:
    """
    Return the language code that's listed in supported languages, possibly
    selecting a more generic variant. Raise LookupError if nothing is found.
    If `strict` is False (the default), look for a country-specific variant
    when neither the language code nor its generic variant is found.
    lru_cache should have a maxsize to prevent from memory exhaustion attacks,
    as the provided language codes are taken from the HTTP request. See also
    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.

    This is equvilant to Django's `django.utils.translation.get_supported_content_language_variant`
    but reads the `WAGTAIL_CONTENT_LANGUAGES` setting instead.
    """
    ...

def get_locales_display_names() -> dict[str, str]:
    """
    Cache of the locale id -> locale display name mapping
    """
    ...

@receiver(setting_changed)
def reset_cache(**kwargs): # -> None:
    """
    Clear cache when global WAGTAIL_CONTENT_LANGUAGES/LANGUAGES/LANGUAGE_CODE settings are changed
    """
    ...

def multigetattr(item, accessor): # -> object | Any:
    """
    Like getattr, but accepts a dotted path as the accessor to be followed to any depth.
    At each step, the lookup on the object can be a dictionary lookup (foo['bar']) or an attribute
    lookup (foo.bar), and if it results in a callable, will be called (provided we can do so with
    no arguments, and it does not have an 'alters_data' property).

    Modelled on the variable resolution logic in Django templates:
    https://github.com/django/django/blob/f331eba6d576752dd79c4b37c41d981daa537fe6/django/template/base.py#L838
    """
    ...

def get_dummy_request(*, path: str = ..., site: Site = ...) -> HttpRequest:
    """
    Return a simple ``HttpRequest`` instance that can be passed to
    ``Page.get_url()`` and other methods to benefit from improved performance
    when no real ``HttpRequest`` instance is available.

    If ``site`` is provided, the ``HttpRequest`` is made to look like it came
    from that Wagtail ``Site``.
    """
    ...

def safe_md5(data=..., usedforsecurity=...): # -> HASH:
    """
    Safely use the MD5 hash algorithm with the given ``data`` and a flag
    indicating if the purpose of the digest is for security or not.

    On security-restricted systems (such as FIPS systems), insecure hashes
    like MD5 are disabled by default. But passing ``usedforsecurity`` as
    ``False`` tells the underlying security implementation we're not trying
    to use the digest for secure purposes and to please just go ahead and
    allow it to happen.
    """
    ...

class BatchProcessor[T]:
    """
    A class to help with processing of an unknown (and potentially very
    high) number of objects.

    Just set ``max_size`` to the maximum number of instances you want
    to be held in memory at any one time, and batches will be sent to the
    ``process()`` method as that number is reached, without you having to
    invoke ``process()`` regularly yourself. Just remember to invoke
    ``process()`` when you're done adding items, otherwise the final batch
    of objects will not be processed.
    """
    def __init__(self, max_size: int) -> None:
        ...

    def __len__(self): # -> int:
        ...

    def add(self, item: T) -> None:
        ...

    def extend(self, iterable: Iterable[T]) -> None:
        ...

    def process(self): # -> None:
        ...

    def pre_process(self): # -> None:
        """
        A hook to allow subclasses to do any pre-processing of the data
        before the ``process()`` method is called.
        """
        ...

    def post_process(self): # -> None:
        """
        A hook to allow subclasses to do any post-processing
        after the ``process()`` method is called, and before
        ``self.items`` is cleared
        """
        ...



class BatchCreator(BatchProcessor[Model]):
    """
    A class to help with bulk creation of an unknown (and potentially very
    high) number of model instances.

    Just set ``max_size`` to the maximum number of instances you want
    to be held in memory at any one time, and batches of objects will
    be created as that number is reached, without you having to invoke
    the ``process()`` method regularly yourself. Just remember to
    invoke ``process()`` when you're done adding items, to ensure
    that the final batch items is saved.

    ``BatchSaver`` is migration-friendly! Just use the ``model``
    keyword argument when initializing to override the hardcoded model
    class with the version from your migration.
    """
    model: ModelBase = ...
    def __init__(self, max_size: int, *, model: ModelBase = ..., ignore_conflicts=...) -> None:
        ...

    def initialize_instance(self, kwargs): # -> Any:
        ...

    def add(self, *, instance: Model = ..., **kwargs) -> None:  # type: ignore[override]
        ...

    def extend(self, iterable: Iterable[Model | dict[str, Any]]) -> None:
        ...

    def get_summary(self): # -> str:
        ...



def make_wagtail_template_fragment_key(fragment_name, page, site, vary_on=...): # -> str:
    """
    A modified version of `make_template_fragment_key` which varies on page and
    site for use with `{% wagtailpagecache %}`.
    """
    ...

