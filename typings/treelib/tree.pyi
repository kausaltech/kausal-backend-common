from collections.abc import Generator
from typing import Callable, Hashable, Literal

from _typeshed import Incomplete, SupportsRichComparison

from .exceptions import (
    DuplicatedNodeIdError as DuplicatedNodeIdError,
    InvalidLevelNumber as InvalidLevelNumber,
    LinkPastRootNodeError as LinkPastRootNodeError,
    LoopError as LoopError,
    MultipleRootError as MultipleRootError,
    NodeIDAbsentError as NodeIDAbsentError,
)
from .node import Node as Node

class Tree:
    ROOT: Literal[0]
    DEPTH: Literal[1]
    WIDTH: Literal[2]
    ZIGZAG: Literal[3]
    node_class = Node
    def __contains__(self, identifier) -> bool: ...
    root: Hashable
    def __init__(
        self, tree: Tree | None = None, deep: bool = False, node_class: type[Node] | None = None, identifier: str | None = None
    ) -> None: ...
    @property
    def identifier(self): ...
    def __getitem__(self, key): ...
    def __len__(self) -> int: ...
    def add_node(self, node, parent: Incomplete | None = None) -> None: ...
    def all_nodes(self): ...
    def all_nodes_itr(self): ...
    def ancestor(self, nid, level: Incomplete | None = None): ...
    def children(self, nid): ...
    def contains(self, nid): ...
    def create_node(
        self,
        tag: Incomplete | None = None,
        identifier: Incomplete | None = None,
        parent: Incomplete | None = None,
        data: Incomplete | None = None,
    ): ...
    def depth(self, node: Incomplete | None = None): ...
    def expand_tree(
        self,
        nid: Hashable | None = None,
        mode=...,
        filter: Callable[[Node], bool] | None = None,
        key: Callable[[Node], SupportsRichComparison] | None = None,
        reverse: bool = False,
        sorting: bool = True,
    ) -> Generator[Incomplete, None, Incomplete]: ...
    def filter_nodes(self, func): ...
    def get_node(self, nid): ...
    def is_branch(self, nid): ...
    def leaves(self, nid: Incomplete | None = None): ...
    def level(self, nid, filter: Incomplete | None = None): ...
    def link_past_node(self, nid) -> None: ...
    def move_node(self, source, destination) -> None: ...
    def is_ancestor(self, ancestor, grandchild): ...
    @property
    def nodes(self): ...
    def parent(self, nid): ...
    def merge(self, nid, new_tree, deep: bool = False) -> None: ...
    def paste(self, nid, new_tree, deep: bool = False) -> None: ...
    def paths_to_leaves(self): ...
    def remove_node(self, identifier): ...
    def remove_subtree(self, nid, identifier: Incomplete | None = None): ...
    def rsearch(self, nid, filter: Incomplete | None = None) -> Generator[Incomplete, None, Incomplete]: ...
    def save2file(
        self,
        filename,
        nid: Incomplete | None = None,
        level=...,
        idhidden: bool = True,
        filter: Incomplete | None = None,
        key: Incomplete | None = None,
        reverse: bool = False,
        line_type: str = 'ascii-ex',
        data_property: Incomplete | None = None,
        sorting: bool = True,
    ): ...
    def show(
        self,
        nid: Incomplete | None = None,
        level=...,
        idhidden: bool = True,
        filter: Incomplete | None = None,
        key: Incomplete | None = None,
        reverse: bool = False,
        line_type: str = 'ascii-ex',
        data_property: Incomplete | None = None,
        stdout: bool = True,
        sorting: bool = True,
    ): ...
    def siblings(self, nid): ...
    def size(self, level: Incomplete | None = None): ...
    def subtree(self, nid, identifier: Incomplete | None = None): ...
    def update_node(self, nid, **attrs) -> None: ...
    def to_dict(
        self,
        nid: Incomplete | None = None,
        key: Incomplete | None = None,
        sort: bool = True,
        reverse: bool = False,
        with_data: bool = False,
    ): ...
    def to_json(self, with_data: bool = False, sort: bool = True, reverse: bool = False): ...
    def to_graphviz(
        self,
        filename: Incomplete | None = None,
        shape: str = 'circle',
        graph: str = 'digraph',
        filter: Incomplete | None = None,
        key: Incomplete | None = None,
        reverse: bool = False,
        sorting: bool = True,
    ) -> None: ...
    @classmethod
    def from_map(cls, child_parent_dict, id_func: Incomplete | None = None, data_func: Incomplete | None = None) -> Tree: ...
