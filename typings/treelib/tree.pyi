from collections.abc import Generator
from typing import Callable, Hashable, Literal, SupportsLessThan

from _typeshed import Incomplete

from .exceptions import (
    DuplicatedNodeIdError as DuplicatedNodeIdError,
    InvalidLevelNumber as InvalidLevelNumber,
    LinkPastRootNodeError as LinkPastRootNodeError,
    LoopError as LoopError,
    MultipleRootError as MultipleRootError,
    NodeIDAbsentError as NodeIDAbsentError,
)
from .node import Node as Node

class Tree:
    ROOT: Literal[0]
    DEPTH: Literal[1]
    WIDTH: Literal[2]
    ZIGZAG: Literal[3]
    node_class = Node
    def __contains__(self, identifier) -> bool: ...
    root: Hashable
    def __init__(self, tree: Tree | None = None, deep: bool = False, node_class: type[Node] | None = None, identifier: str | None = None) -> None: ...
    @property
    def identifier(self): ...
    def __getitem__(self, key): ...
    def __len__(self) -> int: ...
    def add_node(self, node, parent: Incomplete | None = None) -> None: ...
    def all_nodes(self): ...
    def all_nodes_itr(self): ...
    def ancestor(self, nid, level: Incomplete | None = None): ...
    def children(self, nid): ...
    def contains(self, nid): ...
    def create_node(self, tag: Incomplete | None = None, identifier: Incomplete | None = None, parent: Incomplete | None = None, data: Incomplete | None = None): ...
    def depth(self, node: Incomplete | None = None): ...
    def expand_tree(self, nid: Hashable | None = None, mode=..., filter: Callable[[Node], bool] | None = None, key: Callable[[Node], SupportsLessThan] | None = None, reverse: bool = False, sorting: bool = True) -> Generator[Incomplete, None, Incomplete]: ...
    def filter_nodes(self, func): ...
    def get_node(self, nid): ...
    def is_branch(self, nid): ...
    def leaves(self, nid: Incomplete | None = None): ...
    def level(self, nid, filter: Incomplete | None = None): ...
    def link_past_node(self, nid) -> None: ...
    def move_node(self, source, destination) -> None: ...
    def is_ancestor(self, ancestor, grandchild): ...
    @property
    def nodes(self): ...
    def parent(self, nid): ...
    def merge(self, nid, new_tree, deep: bool = False) -> None: ...
    def paste(self, nid, new_tree, deep: bool = False) -> None: ...
    def paths_to_leaves(self): ...
    def remove_node(self, identifier): ...
    def remove_subtree(self, nid, identifier: Incomplete | None = None): ...
    def rsearch(self, nid, filter: Incomplete | None = None) -> Generator[Incomplete, None, Incomplete]: ...
    def save2file(self, filename, nid: Incomplete | None = None, level=..., idhidden: bool = True, filter: Incomplete | None = None, key: Incomplete | None = None, reverse: bool = False, line_type: str = 'ascii-ex', data_property: Incomplete | None = None, sorting: bool = True): ...
    def show(self, nid: Incomplete | None = None, level=..., idhidden: bool = True, filter: Incomplete | None = None, key: Incomplete | None = None, reverse: bool = False, line_type: str = 'ascii-ex', data_property: Incomplete | None = None, stdout: bool = True, sorting: bool = True): ...
    def siblings(self, nid): ...
    def size(self, level: Incomplete | None = None): ...
    def subtree(self, nid, identifier: Incomplete | None = None): ...
    def update_node(self, nid, **attrs) -> None: ...
    def to_dict(self, nid: Incomplete | None = None, key: Incomplete | None = None, sort: bool = True, reverse: bool = False, with_data: bool = False): ...
    def to_json(self, with_data: bool = False, sort: bool = True, reverse: bool = False): ...
    def to_graphviz(self, filename: Incomplete | None = None, shape: str = 'circle', graph: str = 'digraph', filter: Incomplete | None = None, key: Incomplete | None = None, reverse: bool = False, sorting: bool = True) -> None: ...
    @classmethod
    def from_map(cls, child_parent_dict, id_func: Incomplete | None = None, data_func: Incomplete | None = None): ...
